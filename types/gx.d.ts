// DO NOT EDIT THIS FILE! It was generated by running `npm run tsgen`
/// <reference types="./matter" />

/**
 * A utility class for working with containers and calculating their dimensions.
 */
declare class ContainerHelper {
    /**
     * Finds the maximum and minimum X coordinates of the children within the container.
     * @param cont The container containing child objects.
     */
    static findMaxAndMinX(cont: Container): object;

    /**
     * Finds the maximum and minimum Y coordinates of the children within the container.
     * @param cont The container containing child objects.
     */
    static findMaxAndMinY(cont: Container): object;

}

/**
 * A utility class for handling coordinate transformations and calculations.
 */
declare class Coordinate {
    /**
     * Converts the scale of an object to local scale, accounting for parent transformations.
     * @param obj The object whose scale to convert.
     */
    static toLocalScale(obj: PIXI.DisplayObject): object;

    /**
     * Converts the scale of an object to global scale, accounting for parent transformations.
     * @param obj The object whose scale to convert.
     */
    static toGlobalScale(obj: PIXI.DisplayObject): object;

    /**
     * Converts the rotation of an object to global rotation, accounting for parent transformations.
     * @param obj The object whose rotation to convert.
     */
    static toGlobalRotation(obj: PIXI.DisplayObject): number;

    /**
     * Converts the rotation of an object to local rotation, accounting for parent transformations.
     * @param obj The object whose rotation to convert.
     */
    static toLocalRotation(obj: PIXI.DisplayObject): number;

    /**
     * Retrieves global positioning and dimensions data of an object within its parent hierarchy.
     * @param obj The object whose data to retrieve.
     * @param cX Custom X coordinate.
     * @param cY Custom Y coordinate.
     * @param cW Custom width.
     * @param cH Custom height.
     */
    static getGlobalData(obj: PIXI.DisplayObject, cX?: number, cY?: number, cW?: number, cH?: number): object;

    /**
     * Retrieves local positioning and dimensions data of an object within its parent hierarchy.
     * @param obj The object whose data to retrieve.
     * @param cX Custom X coordinate.
     * @param cY Custom Y coordinate.
     * @param cW Custom width.
     * @param cH Custom height.
     */
    static getLocalData(obj: PIXI.DisplayObject, cX?: number, cY?: number, cW?: number, cH?: number): object;

}

/**
 * A utility class for handling resizing and positioning of game objects.
 */
declare class ResizeHelper {
    /**
     * Sets the base width and height of a game object based on its type.
     * @param gameObject The game object whose base width and height to set.
     */
    static setBaseWidthHeight(gameObject: object): object;

    /**
     * Calculates available space and positioning information for a game object.
     * @param gameObject The game object for which to calculate space.
     * @param orientation The orientation of the resize data (e.g., "horizontal" or "vertical").
     */
    static getSpace(gameObject: object, orientation: string): object;

    /**
     * Retrieves positioning and dimensions bounds of a game object.
     * @param gameObject The game object for which to retrieve bounds.
     */
    static getBounds(gameObject: object): object;

    /**
     * Calculates scaling factors based on available space and resize data.
     * @param gameObject The game object for which to calculate scaling factors.
     * @param orientation The orientation of the resize data (e.g., "horizontal" or "vertical").
     */
    static getScale(gameObject: object, orientation: string): object;

    /**
     * Calculates positioning based on available space and alignment data.
     * @param gameObject The game object for which to calculate positioning.
     * @param orientation The orientation of the resize data (e.g., "horizontal" or "vertical").
     */
    static getPosition(gameObject: object, orientation: string): object;

    /**
     * Finds the maximum and minimum X positions among the children of a game object.
     * @param obj The game object whose children to analyze.
     */
    static findMaxAndMinX(obj: object): object;

    /**
     * Finds the maximum and minimum Y positions among the children of a game object.
     * @param obj The game object whose children to analyze.
     */
    static findMaxAndMinY(obj: object): object;

    /**
     * Recalculates the bounds and dimensions of a container game object after resizing.
     * @param obj The container game object to recalculate bounds for.
     */
    static recalculateContainerBounds(obj: object): void;

}

/**
 * Represents a controller for managing scenes and objects in a 2D game or application.
 */
declare class SceneController {
    /**
     * 
     * @param scene2D The 2D scene instance.
     * @param editorConfig The editor configuration.
     */
    constructor(scene2D: Scene2D, editorConfig: EditorConfig);

    /**
     * Clones a given object and its children, if any.
     * @param obj The object to clone.
     */
    cloneObject(obj: PIXI.DisplayObject): PIXI.DisplayObject;

    /**
     * Instantiates a prefab by creating objects based on prefab data.
     * @param prefabName The name of the prefab to instantiate.
     */
    instantiate(prefabName: string): PIXI.DisplayObject;

    /**
     * Recursively retrieves an array of all child objects within a given parent object.
     * @param parent The parent object to retrieve children from.
     */
    getAllChilds(parent: PIXI.DisplayObject): PIXI.DisplayObject[];

    /**
     * Retrieves an object by its name from the specified scene or list of scenes.
     * @param name The name of the object to retrieve.
     * @param fromScene The scene to search for the object.
     */
    getObject(name: string, fromScene?: Scene2D): PIXI.DisplayObject;

    /**
     * Retrieves an object by its UUID from the specified scene or list of scenes.
     * @param uuid The UUID of the object to retrieve.
     * @param fromScene The scene to search for the object.
     */
    getObjectByUUID(uuid: string, fromScene?: Scene2D): PIXI.DisplayObject;

    /**
     * Updates all entities within the scenes.
     * @param time The current time.
     * @param delta The time elapsed since the last update.
     */
    update(time: number, delta: number): void;

    /**
     * Resizes all entities within the scenes.
     * @param w The new width.
     * @param h The new height.
     */
    resize(w: number, h: number): void;

    /**
     * Retrieves a scene by its name.
     * @param name The name of the scene to retrieve.
     */
    getSceneByName(name: string): Scene2D;

    /**
     * Starts a specified scene.
     * @param name The name of the scene to start.
     * @param removeCurScene Whether to remove the current scene.
     */
    start(name: string, removeCurScene?: boolean): Scene2D;

    /**
     * Fills public variables in components of the provided entity list.
     * @param entityList The list of entities to fill variables for.
     */
    fillPublicVariables(entityList: PIXI.DisplayObject[]): void;

    /**
     * Removes an object from the scene and related data.
     * @param obj The object to remove.
     */
    removeObject(obj: PIXI.DisplayObject): void;

    /**
     * Removes a scene by its name.
     * @param name The name of the scene to remove.
     */
    remove(name: string): void;

    /**
     * Removes all scenes and related data.
     */
    removeAll(): void;

}

/**
 * Converts RGB color values to a hexadecimal representation.
 * @param r The red color component (0-1).
 * @param g The green color component (0-1).
 * @param b The blue color component (0-1).
 */
declare function RGBToHex(r: number, g: number, b: number): string;

/**
 * Class responsible for loading various types of assets in a 2D game.
 */
declare class Loader2D {
    /**
     * Load a list of assets and call the callback when all assets are loaded.
     * @param assetList List of asset objects to load.
     * @param callback Callback function to execute after all assets are loaded.
     */
    load(assetList: Object[], callback: Function): void;

    /**
     * Load a Spine animation.
     * @param key Key to identify the loaded asset.
     * @param imageFile Image file path.
     * @param jsonData JSON data for the Spine animation.
     * @param atlasData Atlas data for the Spine animation.
     * @param callback Callback function to execute after the Spine animation is loaded.
     */
    loadSpine(key: string, imageFile: string, jsonData: string, atlasData: string, callback: Function): void;

    /**
     * Load a bitmap font.
     * @param key Key to identify the loaded asset.
     * @param imageFile Image file path.
     * @param xmlData XML data for the bitmap font.
     * @param callback Callback function to execute after the bitmap font is loaded.
     */
    loadBitmapFont(key: string, imageFile: string, xmlData: string, callback: Function): void;

    /**
     * Load an image.
     * @param key Key to identify the loaded asset.
     * @param imageFile Image file path.
     * @param callback Callback function to execute after the image is loaded.
     */
    loadImage(key: string, imageFile: string, callback: Function): void;

    /**
     * Load a video.
     * @param key Key to identify the loaded asset.
     * @param videoFile Video file path.
     * @param callback Callback function to execute after the video is loaded.
     */
    loadVideo(key: string, videoFile: string, callback: Function): void;

    /**
     * Load an atlas.
     * @param key Key to identify the loaded asset.
     * @param imageFile Image file path.
     * @param atlasData Atlas data.
     * @param callback Callback function to execute after the atlas is loaded.
     */
    loadAtlas(key: string, imageFile: string, atlasData: Object, callback: Function): void;

    /**
     * Load a glTF model.
     * @param key Key to identify the loaded asset.
     * @param gltfSrc glTF source data.
     * @param callback Callback function to execute after the glTF model is loaded.
     */
    loadGltf(key: string, gltfSrc: string, callback: Function): void;

}

/**
 * Class representing the main 2D application.
 */
declare class Main2D {
    /**
     * 
     * @param config The configuration options for the PIXI application.
     * @param editorConfig The editor configuration options.
     * @param assets The assets to load.
     * @param readyCallback The callback function to be called when assets are loaded and the app is ready.
     * @param resizeCallback The callback function to be called when the canvas is resized.
     * @param updateCallback The callback function to be called on each update tick.
     */
    constructor(config: object, editorConfig: object, assets: object, readyCallback: Function, resizeCallback: Function, updateCallback: Function);

    /**
     * Pause the application's update loop.
     */
    pause(): void;

    /**
     * Resume the application's update loop.
     */
    resume(): void;

    /**
     * Update the application's logic.
     * @param time The current time in milliseconds.
     * @param delta The time elapsed since the last frame update.
     */
    update(time: number, delta: number): void;

    /**
     * Render the PIXI application.
     */
    render(): void;

    /**
     * Initialize the top banner.
     * @param data Data for initializing the top banner.
     */
    initTopBanner(data: object): void;

    /**
     * Handle assets loaded event.
     */
    assetsLoaded(): void;

    /**
     * Get all animation names and their associated UUIDs from loaded resources.
     */
    getAllAnims(): object;

    /**
     * Initialize the post-processing effects.
     */
    initPostProcess: any;

    /**
     * Resize the PIXI canvas and update scene properties accordingly.
     * @param w The new width of the canvas.
     * @param h The new height of the canvas.
     */
    resizeCanvas(w: number, h: number): void;

    /**
     * Resize the PIXI canvas and its contents.
     * @param w The new width.
     * @param h The new height.
     */
    resize(w: number, h: number): void;

}

/**
 * A class to handle responsive resizing of the PIXI canvas and its contents.
 */
declare class Responsive {
    /**
     * 
     * @param pixiApp The PIXI application instance.
     * @param scene The PIXI scene to be resized responsively.
     */
    constructor(pixiApp: PIXI.Application, scene: PIXI.Container);

    /**
     * Resize the PIXI canvas and maintain the aspect ratio of the content.
     * @param app The PIXI application instance.
     * @param iw The new width of the canvas.
     * @param ih The new height of the canvas.
     */
    resize(app: PIXI.Application, iw: number, ih: number): Object;

    /**
     * Resize the objects within the PIXI scene based on the new dimensions.
     * @param w The new width of the canvas.
     * @param h The new height of the canvas.
     */
    resizeObjects(w: number, h: number): void;

    /**
     * Recursively collect all game objects within a PIXI container.
     * @param container The PIXI container to collect objects from.
     * @param resultArray The array to store collected objects.
     */
    getAllGameObjects(container: PIXI.Container, resultArray: PIXI.DisplayObject[]): void;

}

/**
 * Factory class for creating game objects.
 */
declare class GameObjectFactory {
    /**
     * The scene to which game objects will be added.
     */
    scene: Scene;

    /**
     * Adds a sprite game object.
     * @param x X position of the sprite.
     * @param y Y position of the sprite.
     * @param texture Texture key of the sprite.
     */
    sprite(x: number, y: number, texture: string): Sprite;

    /**
     * Adds an animated sprite game object.
     * @param x X position of the sprite.
     * @param y Y position of the sprite.
     * @param animKey Animation key of the sprite.
     * @param autoplay Whether to play the animation immediately. Default true.
     * @param loop Whether to loop the animation. Default false.
     */
    animatedSprite(x: number, y: number, animKey: string, autoplay?: boolean, loop?: boolean): AnimatedSprite;

    /**
     * Adds a container game object.
     * @param x X position of the container.
     * @param y Y position of the container.
     */
    container(x: number, y: number): Container;

    /**
     * Adds a text game object.
     * @param x X position of the text.
     * @param y Y position of the text.
     * @param text The text content. Default "".
     * @param style The style configuration for the text. Default {}.
     */
    text(x: number, y: number, text?: string, style?: object): Text;

    /**
     * Adds a Spine game object.
     * @param x X position of the Spine object.
     * @param y Y position of the Spine object.
     * @param spineName The name of the Spine object.
     * @param skinName The name of the Spine object's skin.
     * @param animName The name of the initial animation to play.
     * @param loop Whether to loop the animation. Default false.
     */
    spine(x: number, y: number, spineName: string, skinName: string, animName: string, loop?: boolean): Spine;

    /**
     * Adds a Graphics game object.
     * @param x X position of the Graphics object.
     * @param y Y position of the Graphics object.
     */
    graphics(x: number, y: number): Graphics;

    /**
     * Adds a Rectangle game object.
     * @param x X position of the Rectangle object.
     * @param y Y position of the Rectangle object.
     * @param width Width of the Rectangle.
     * @param height Height of the Rectangle.
     * @param color Color of the Rectangle.
     */
    rectangle(x: number, y: number, width: number, height: number, color: string): Rectangle;

    /**
     * Adds a NineSlice game object.
     * @param x X position of the NineSlice object.
     * @param y Y position of the NineSlice object.
     * @param texture Texture key of the NineSlice object.
     * @param width Width of the NineSlice object.
     * @param height Height of the NineSlice object.
     * @param left Left size of the NineSlice object.
     * @param right Right size of the NineSlice object.
     * @param top Top size of the NineSlice object.
     * @param bottom Bottom size of the NineSlice object.
     */
    nineslice(x: number, y: number, texture: string, width: number, height: number, left: number, right: number, top: number, bottom: number): NineSlice;

    /**
     * Adds a ParticleEmitter game object.
     * @param x X position of the ParticleEmitter object.
     * @param y Y position of the ParticleEmitter object.
     * @param particleData Particle configuration data.
     */
    particleEmitter(x: number, y: number, particleData: object): ParticleEmitter;

    /**
     * Adds a Viewport game object.
     * @param options Viewport configuration options.
     */
    viewport(options: object): Viewport;

}

/**
 * Base class for game objects.
 */
declare class GameObject {
    /**
     * The PIXI display object associated with this game object.
     */
    pixiObj: PIXI.DisplayObject;

    /**
     * The anchor point of the PIXI object.
     */
    anchor: PIXI.Point | null;

    /**
     * The pivot point of the PIXI object.
     */
    pivot: PIXI.Point | null;

    /**
     * The base width of the PIXI object.
     */
    baseWidth: number;

    /**
     * The base height of the PIXI object.
     */
    baseHeight: number;

    /**
     * Event listeners attached to the game object.
     */
    eventListeners: {[key: string]:  Array<function()>};

    /**
     * Returns an array of child GameObjects associated with this GameObject.
     */
    children: any;

    /**
     * Returns the parent GameObject of this GameObject.
     */
    parent: any;

    /**
     * Sets the visibility of the GameObject.
     */
    visible: any;

    /**
     * Sets the x-coordinate of the GameObject.
     */
    x: any;

    /**
     * Sets the y-coordinate of the GameObject.
     */
    y: any;

}

/**
 * Adds a child PIXI display object to the current game object.
 * @param child The child game object to add.
 */
declare function addChild(child: GameObject): void;

/**
 * Removes a child PIXI display object from the current game object.
 * @param child The child game object to remove.
 */
declare function removeChild(child: GameObject): void;

/**
 * Attaches a child game object to the current game object and repositions it to match world position.
 * @param child The child game object to attach.
 */
declare function attach(child: GameObject): void;

/**
 * Removes the current game object from its parent.
 */
declare function remove(): void;

/**
 * The `gx` class provides methods for initializing the game scene and adding game objects.
 */
declare class gx {
    /**
     * Initialize the game scene and setup various global variables.
     * @param pixiApp The PIXI application instance.
     * @param editorConfig The editor configuration object.
     * @param TextureCache The PIXI texture cache.
     * @param Resources The PIXI loader resources.
     */
    static init(pixiApp: PIXI.Application, editorConfig: Object, TextureCache: Object, Resources: Object): Scene;

    /**
     * Factory for creating game objects and adding them to the scene.
     */
    add: GameObjectFactory;

    /**
     * Utility methods for game development.
     */
    utils: Utils;

}

/**
 * A class to apply a sprite mask to a PIXI DisplayObject.
 */
declare class SpriteMask {
    /**
     * 
     * @param obj The DisplayObject to apply the mask to.
     * @param mask The sprite mask to apply.
     * @param invertAlpha Whether to invert the alpha of the mask. Default false.
     */
    constructor(obj: PIXI.DisplayObject, mask: PIXI.Sprite, invertAlpha?: boolean);

    /**
     * The DisplayObject to apply the mask to.
     */
    obj: PIXI.DisplayObject;

    /**
     * The sprite mask to apply.
     */
    mask: PIXI.Sprite;

    /**
     * Whether to invert the alpha of the mask.
     */
    invertAlpha: boolean;

    /**
     * Initialize the sprite mask.
     */
    init(): void;

}

/**
 * Utility class containing various helper methods.
 */
declare class Utils {
    /**
     * 
     * @param pixiScene The PIXI scene.
     */
    constructor(pixiScene: PIXI.Container);

    /**
     * Apply a sprite mask to a sprite.
     * @param sprite The sprite to apply the mask to.
     * @param mask The sprite mask to apply.
     * @param invertAlpha Whether to invert the alpha of the mask.
     */
    spriteMask(sprite: PIXI.Sprite, mask: PIXI.Sprite, invertAlpha: boolean): void;

    /**
     * Create a curve animation.
     * @param startPoint The start point of the curve.
     * @param endPoint The end point of the curve.
     * @param controlPoint The control point of the curve.
     * @param enableDebug Whether to enable debug graphics. Default false.
     * @param duration The duration of the animation.
     * @param callback The callback function for each animation step.
     */
    curve(startPoint: Object, endPoint: Object, controlPoint: Object, enableDebug: boolean, duration: number, callback: Function): void;

}

/**
 * Adds a new component to the entity
 * @param component The component to add
 * @param componentName The component name string
 */
declare function addComponent(component: Component, componentName: String): void;

/**
 * Removes a component from the entity
 * @param componentClass The class of the component to remove
 */
declare function removeComponent(componentClass: Component): void;

/**
 * Gets a component from the entity
 * @param componentName The name of the component to get
 */
declare function getComponent(componentName: string): Component;

/**
 * Returns true if the entity has a component of the specified type
 * @param componentName The name of the component to check for
 */
declare function hasComponent(componentName: string): boolean;

/**
 * Returns an array of all components attached to the entity
 */
declare function getAllComponents(): Component[];

declare type integer = number;

declare module 'phaser' {
    export = Phaser;

}

